# app.py
#
# This is the Flask web API for the cybersecurity audit AI system.
# Flask is a lightweight Python framework for building web APIs.
#
# This file does three things:
# 1. Loads the trained Random Forest model when the server starts
# 2. Provides a /predict endpoint that accepts vulnerability data
# 3. Returns a risk score AND a plain-English explanation to whoever called it
#
# The plain-English explanation is generated by PlainEnglishService,
# which maps the vulnerability to a pre-written template and calculates
# readability scores to confirm the text is accessible to non-technical users.

from flask import Flask, jsonify, request
from model_trainer import CybersecurityRiskModel
from feature_engineering import VulnerabilityFeatureEngineer
from plain_english_service import PlainEnglishService  # Our new plain-English generator
import os
import numpy as np

app = Flask(__name__)

# Global variables that hold the model and services after startup
trained_model = None        # The trained Random Forest model
feature_engineer = None     # The feature transformer (used to convert input to model format)
plain_english = None        # The plain-English explanation service

def transform_single_vulnerability(vulnerability_data, saved_feature_engineer):
    """
    Transform a single vulnerability using the already-fitted feature engineer.

    This ensures we use the same TF-IDF vocabulary and one-hot encoding as training,
    preventing the "111 features vs 11 features" mismatch.

    Args:
        vulnerability_data (list): Single vulnerability dictionary
        saved_feature_engineer: The fitted feature engineer from training

    Returns:
        dict: Processed features in same format as training
    """
    if not vulnerability_data or len(vulnerability_data) != 1:
        raise ValueError("transform_single_vulnerability expects exactly one vulnerability")

    vuln = vulnerability_data[0]

    # Extract individual components
    description = vuln['description']
    vulnerability_type = vuln['type']
    cvss_score = vuln['cvss']

    # Use the already-fitted TF-IDF vectorizer (same vocabulary as training)
    text_features = saved_feature_engineer.vectorizer.transform([description]).toarray()

    # Use the already-fitted one-hot encoder (same categories as training)
    type_features = saved_feature_engineer.encoder.transform([[vulnerability_type]])

    # CVSS score as feature (same as training)
    cvss_features = np.array([[cvss_score]])

    # Combine features in same order as training
    combined_features = np.hstack([
        text_features,      # TF-IDF text features
        type_features,      # One-hot encoded types
        cvss_features       # CVSS score
    ])

    return {
        'features': combined_features,
        'targets': np.array([cvss_score]),  # Not used for prediction, but for consistency
        'feature_names': saved_feature_engineer.feature_names,
        'original_data': vulnerability_data
    }

def load_trained_model():
    """
    Load the trained ML model and initialise all services on startup.

    This function runs once when the Flask server starts. It loads:
    - The trained Random Forest model from disk
    - The fitted feature engineer (used to transform input data)
    - The PlainEnglishService (used to generate explanations)

    Returns:
        bool: True if everything loaded successfully, False otherwise
    """
    global trained_model, feature_engineer, plain_english

    model_path = "model/trained_model.pkl"

    # Check that the trained model file exists before trying to load it
    if not os.path.exists(model_path):
        print(f"‚ùå Trained model not found at {model_path}")
        print("   Run model_trainer.py first to train the model.")
        return False

    try:
        # Load the trained model and feature engineer from disk
        trained_model, feature_engineer = CybersecurityRiskModel.load_model(model_path)

        # The feature engineer must also be present (saved alongside the model)
        if feature_engineer is None:
            print("‚ùå Feature engineer not found in saved model file.")
            print("   Please retrain the model by running model_trainer.py.")
            return False

        # Initialise the plain-English explanation service
        plain_english = PlainEnglishService()

        print("‚úÖ ML model loaded successfully")
        print("‚úÖ Feature engineer loaded successfully")
        print("‚úÖ Plain-English service initialised")
        print("‚úÖ API is ready to accept requests")
        return True

    except Exception as e:
        print(f"‚ùå Error loading model: {e}")
        return False

@app.route("/health", methods=["GET"])
def health_check():
    """
    Health check endpoint to verify the API is running and model is loaded.
    """
    model_status = "loaded" if trained_model and trained_model.is_trained else "not loaded"

    return jsonify({
        "status": "healthy",
        "message": "Cybersecurity Audit AI API is running",
        "model_status": model_status,
        "endpoints": {
            "/predict": "POST - Make risk predictions",
            "/health": "GET - Check API status"
        }
    })

@app.route("/predict", methods=["POST"])
def predict_risk():
    """
    Main prediction endpoint. Accepts vulnerability data and returns a risk
    score alongside a plain-English explanation.

    Expected JSON input:
    {
        "description": "SQL injection vulnerability in login form",
        "type": "SQL Injection",
        "cvss": 7.5
    }

    Returns JSON output:
    {
        "risk_score": 7.8,
        "severity": "HIGH",
        "severity_context": "This is a serious issue...",
        "plain_english": {
            "title": "...",
            "what_this_means": "...",
            "why_it_matters": "..."
        },
        "readability": {
            "flesch_reading_ease": 65.2,
            "flesch_kincaid_grade": 6.1,
            "flesch_pass": true,
            "grade_pass": true
        }
    }
    """
    global trained_model, feature_engineer, plain_english

    # Return an error if the model has not been loaded yet
    if not trained_model or not trained_model.is_trained:
        return jsonify({
            "error": "Model not loaded",
            "message": "Run model_trainer.py first to train the model, then restart the API."
        }), 503

    try:
        # Parse the incoming JSON request body
        data = request.get_json()

        # Reject empty requests
        if not data:
            return jsonify({
                "error": "Empty request",
                "message": "Please send vulnerability data as JSON in the request body."
            }), 400

        # Check all required fields are present
        required_fields = ['description', 'type', 'cvss']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    "error": f"Missing field: {field}",
                    "message": f"The field '{field}' is required."
                }), 400

        # Validate CVSS score is a number within the valid range
        if not isinstance(data['cvss'], (int, float)) or not (0 <= data['cvss'] <= 10):
            return jsonify({
                "error": "Invalid CVSS score",
                "message": "CVSS score must be a number between 0.0 and 10.0"
            }), 400

        # Package the input into the format expected by the feature engineer
        vulnerability_input = [{
            'cve': 'user-input',
            'description': data['description'],
            'type': data['type'],
            'cvss': data['cvss']
        }]

        # Transform the input using the same process used during training
        transformed = transform_single_vulnerability(vulnerability_input, feature_engineer)

        if transformed is None:
            return jsonify({
                "error": "Transformation error",
                "message": "Could not process the vulnerability data for prediction."
            }), 500

        # Run the ML model to get a predicted risk score
        features = transformed['features']
        risk_score = float(trained_model.predict(features)[0])

        # Generate the plain-English explanation using the PlainEnglishService
        explanation = plain_english.generate_explanation(
            description=data['description'],
            vulnerability_type=data['type'],
            risk_score=risk_score
        )

        # If the plain-English service returned an error, surface it clearly
        if explanation.get("error"):
            return jsonify({
                "error": "Plain-English generation failed",
                "message": explanation.get("message", "Unknown error in explanation service.")
            }), 500

        # Build and return the full response
        return jsonify({
            "risk_score": round(risk_score, 2),
            "severity": explanation.get("severity", "UNKNOWN"),
            "severity_context": explanation.get("severity_context", ""),
            "plain_english": explanation.get("plain_english", {}),
            "readability": explanation.get("readability", {})
        })

    except Exception as e:
        # Catch any unexpected errors and return a clear message
        print(f"Error in /predict: {e}")
        return jsonify({
            "error": "Prediction failed",
            "message": str(e)
        }), 500

@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors."""
    return jsonify({
        "error": "Endpoint not found",
        "message": "The requested URL was not found on this server"
    }), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors."""
    return jsonify({
        "error": "Internal server error",
        "message": "An unexpected error occurred"
    }), 500

# Load the model when the app starts
if __name__ == "__main__":
    print("üîÑ Starting Cybersecurity Audit AI Flask API...")

    if load_trained_model():
        print("üåê Starting Flask server on http://127.0.0.1:5000")
        print("üìñ API Documentation:")
        print("   GET  /health  - Check API status")
        print("   POST /predict - Make risk predictions")
        print("\nExample prediction request:")
        print('  curl -X POST http://127.0.0.1:5000/predict \\')
        print('    -H "Content-Type: application/json" \\')
        print('    -d \'{"description": "SQL injection vulnerability", "type": "SQL Injection", "cvss": 7.5}\'')

    app.run(host="0.0.0.0", port=5000, debug=True)