package com.cyberaudit.backend.service;

import com.cyberaudit.backend.entity.Scan;
import com.cyberaudit.backend.entity.Vulnerability;
import com.cyberaudit.backend.repository.ScanRepository;
import com.cyberaudit.backend.repository.VulnerabilityRepository;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

/**
 * VulnerabilityService - Handles all vulnerability operations
 * When NMAP or ZAP finds security problems, this service saves them.
 * 
 */
@Service // Spring magic: manages this class automatically
public class VulnerabilityService {

    // Tools that talk to the database
    // Spring gives us these automatically
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ScanRepository scanRepository;

    // Spring calls this when starting up
    public VulnerabilityService(VulnerabilityRepository vulnerabilityRepository, ScanRepository scanRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.scanRepository = scanRepository;
    }

    // CREATE - Adding vulnerabilities
    /**
     * Add a new vulnerability to a scan
     * Use this when NMAP or ZAP finds a problem
     */
    public Vulnerability addVulnerability(Long scanId, String name, String severity, String description,
            String sourceTool) {
        // Find which scan this belongs to
        Optional<Scan> scanOptional = scanRepository.findById(scanId);

        if (scanOptional.isPresent()) {
            Scan scan = scanOptional.get();

            // Create the vulnerability
            Vulnerability vulnerability = new Vulnerability();
            vulnerability.setScan(scan);
            vulnerability.setName(name);
            vulnerability.setSeverity(severity);
            vulnerability.setDescription(description);
            vulnerability.setSourceTool(sourceTool);

            return vulnerabilityRepository.save(vulnerability);
        }

        return null; // Scan not found
    }

    /**
     * Add vulnerability with AI risk score already calculated
     */
    public Vulnerability addVulnerabilityWithScore(Long scanId, String name, String severity, String description,
            String sourceTool, BigDecimal riskScore) {
        // Add the vulnerability first
        Vulnerability vulnerability = addVulnerability(scanId, name, severity, description, sourceTool);

        // Then add the risk score
        if (vulnerability != null) {
            vulnerability.setRiskScore(riskScore);
            return vulnerabilityRepository.save(vulnerability);
        }

        return null;
    }

    // READ - Finding vulnerabilities
    /**
     * Find a vulnerability by its ID
     */
    public Optional<Vulnerability> getVulnerabilityById(Long id) {
        return vulnerabilityRepository.findById(id);
    }

    /**
     * Get all vulnerabilities
     */
    public List<Vulnerability> getAllVulnerabilities() {
        return vulnerabilityRepository.findAll();
    }

    /**
     * Get all vulnerabilities found in a specific scan
     */
    public List<Vulnerability> getVulnerabilitiesByScanId(Long scanId) {
        return vulnerabilityRepository.findByScanId(scanId);
    }

    /**
     * Get vulnerabilities by how serious they are
     */
    public List<Vulnerability> getVulnerabilitiesBySeverity(String severity) {
        return vulnerabilityRepository.findBySeverity(severity);
    }

    /**
     * Get vulnerabilities by which tool found them
     */
    public List<Vulnerability> getVulnerabilitiesByTool(String sourceTool) {
        return vulnerabilityRepository.findBySourceTool(sourceTool);
    }

    /**
     * Get high-risk vulnerabilities (above a certain score)
     */
    public List<Vulnerability> getHighRiskVulnerabilities(BigDecimal threshold) {
        return vulnerabilityRepository.findByRiskScoreGreaterThan(threshold);
    }

    /**
     * Get vulnerabilities for a scan, sorted by risk (most dangerous first)
     */
    public List<Vulnerability> getVulnerabilitiesByScanIdSortedByRisk(Long scanId) {
        return vulnerabilityRepository.findByScanIdOrderByRiskScoreDesc(scanId);
    }

    /**
     * Get vulnerabilities that haven't been scored by AI yet
     */
    public List<Vulnerability> getUnscoredVulnerabilities() {
        return vulnerabilityRepository.findByRiskScoreIsNull();
    }

    /**
     * Get vulnerabilities that have AI scores
     */
    public List<Vulnerability> getScoredVulnerabilities() {
        return vulnerabilityRepository.findByRiskScoreIsNotNull();
    }

    // UPDATE - Changing vulnerability data
    /**
     * Update the AI risk score for a vulnerability
     */
    public Vulnerability updateRiskScore(Long id, BigDecimal riskScore) {
        Optional<Vulnerability> vulnOptional = vulnerabilityRepository.findById(id);

        if (vulnOptional.isPresent()) {
            Vulnerability vulnerability = vulnOptional.get();
            vulnerability.setRiskScore(riskScore);
            return vulnerabilityRepository.save(vulnerability);
        }

        return null; // Not found
    }

    /**
     * Update the description
     */
    public Vulnerability updateDescription(Long id, String newDescription) {
        Optional<Vulnerability> vulnOptional = vulnerabilityRepository.findById(id);

        if (vulnOptional.isPresent()) {
            Vulnerability vulnerability = vulnOptional.get();
            vulnerability.setDescription(newDescription);
            return vulnerabilityRepository.save(vulnerability);
        }

        return null; // Not found
    }

    // DELETE - Removing vulnerabilities
    /**
     * Delete a vulnerability
     */
    public void deleteVulnerability(Long id) {
        vulnerabilityRepository.deleteById(id);
    }

    /**
     * Delete all vulnerabilities for a scan
     */
    public void deleteVulnerabilitiesByScanId(Long scanId) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findByScanId(scanId);
        vulnerabilityRepository.deleteAll(vulnerabilities);
    }

    // Helpful extras

    /**
     * Count how many vulnerabilities exist
     */
    public long countAllVulnerabilities() {
        return vulnerabilityRepository.count();
    }

    /**
     * Count vulnerabilities found in a scan
     */
    public long countVulnerabilitiesByScanId(Long scanId) {
        return vulnerabilityRepository.countByScanId(scanId);
    }

    /**
     * Count vulnerabilities by severity
     */
    public long countVulnerabilitiesBySeverity(String severity) {
        return vulnerabilityRepository.countBySeverity(severity);
    }

    /**
     * Check if a vulnerability exists
     */
    public boolean vulnerabilityExists(Long id) {
        return vulnerabilityRepository.existsById(id);
    }
}
